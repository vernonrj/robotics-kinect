/////////////////////////////////// SETUP SERVOS AND MOTORS ////////////////////////////////////////////
#pragma config(Hubs,  S1, HTMotor,  HTServo,  none,     none)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_3,    fingers,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    thumb,                tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    wrist,                tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    shoulder,             tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma platform(NXT)

/**
 * @file
 * @brief nxt entry point
 */

#include "logging.h"
#include "bluetooth.h"
#include "servos.h"

/**
 * @brief max size of message that can be received over bluetooth
 */
#define BT_MAX_MSG_SIZE MOTORCTRL_MAX_RES


static int processAction(ubyte *str);



/**
 * @brief main task
 */
task main()
{
    nMotorEncoder[motorE] = 0;  // clear the TETRIX encoders in motors D and E
    nMotorEncoder[motorD] = 0;
    ubyte nRcvBuffer[BT_MAX_MSG_SIZE];
    bNxtLCDStatusDisplay = true;
    wait1Msec(2000); // Give time to start the program at the far end as well

    // run until a break signal is sent (set in process_result)
    int process_result;
    do {
        if (false == checkBTLinkConnected())
        {
            ErrorFatal("Disconnected");
            return;
        }
        // wait until a message is available over bluetooth, then return it
        process_result = readMessage(nRcvBuffer, BT_MAX_MSG_SIZE);
        if (process_result < 0)
        {
            LogMsg("bt failure");
            wait1Msec(1000);
            continue;
        }
        else if (process_result > 0)
        {
            if (time1[T1] < 100)
            {
                // zero out if running for more than 10 msecs without
                // an update
                processAction(NULL);
            }
            else
            {
                wait1Msec(1);
            }
            continue;
        }
        // uncomment to send message back to confirm received
        // TODO: this didn't seem to work when it was uncommented
        //writeMessage(nRcvBuffer, BT_MAX_MSG_SIZE);
        // process message read from bluetooth
        process_result = processAction(nRcvBuffer);
        if (process_result < 0)
        {
            string str;
            StringFromChars(str, (char*)nRcvBuffer);
            LogMsg("bad str");
            continue;
        }
    } while (process_result == 0);

    return;
}



/**
 * @brief process an action contained in str and run action.
 *
 * Currently, takes a message received over bluetooth and
 * parses characters received. Can receive multiple characters,
 * so for instance, receiving an 'ff' will say "forward *2".
 * @returns
 * On success, returns 0. On error, returns -1.
 */
static int processAction(ubyte *str)
{
    motorctrl_t mctrl;
    motorctrl_update(&mctrl, str);
    int motor_left = motorctrl_motor_left(mctrl);
    int motor_right = motorctrl_motor_right(mctrl);

    string log_str;
    sprintf(log_str, "%i | %i", motor_left, motor_right);
    LogMsg(log_str);
    motor[motorD] = motor_left;
    motor[motorE] = motor_right;
    ClearTimer(T1);

    return 0;
}



